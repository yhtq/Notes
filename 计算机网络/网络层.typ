#import "../template.typ": *
#show: note.with(
  title: "计算机网络",
  author: "YHTQ",
  date: none,
  logo: none,
)
#let chapter2 = [
= 网络层
  == 基本功能
    将主机端数据经由物理链路，经过路由器交换机等网络设备，交付到目的主机。
  == 服务模型
    - 面向连接 | 无连接
    - 可靠传输 | 不可靠传输
    - 服务质量保障 | 基本保障 | 不保障
    历史上这些问题都有过很大争议，时至今日最终胜出的是 internet 协议，提供无连接数据报文服务，同时几乎不做任何保障，复杂问题全部交由传输层。\
    一部分是因为网络中路由器等设备要承载巨大的数据量，如果处理逻辑复杂会导致网络设备的成本过高。\
    同时，由于协议简单，在不同协议的网络中也可以实现向下兼容，与其他协议的网络互联。

    网络结构往往是一个复杂的图，两点之间可能有极多的路径，每个数据包都有可能走不同的路径，这导致可能出现严重的乱序问题。乱序包在传输层以上会产生极大负担，因此 internet 也需要一定程度上防止乱序的发生。
  == 关键功能
    + 转发
      根据报文头部的地址信息，决定将报文转发到哪个路由器接口。
    + 路由
      根据网络情况和路由算法、协议，规划数据报文的转发路径。\
      计算方法往往有：
        - 分布式协作，各个路由器协作计算
        - 软件定义网络：新型措施，设计中心化的计算服务器计算路由方式，下发到路由器
    随着软件定义网络概念的提出，网络层也被分为数据平面与控制平面两个概念。数据平面指负责数据转发的部分，控制平面指负责路由计算的部分。
    === 数据平面
      负责执行转发函数，按照转发表和包的目的地决定出口端口。\
      流程：
      - 链路层解封装，IP 地址校验
      - 获取目的 IP 地址，基于最长前缀匹配查找转发表
      - 若查找失败，直接丢弃
      - 若查找成功，将数据包转发至对应端口：
        - IP 头部 TTL 减一，重新计算校验和
        - 换取转发出接口和下一跳链路层地址
        - 重新进行链路层封装，建立连接发送报文
      路由器往往有多个输入输出端口，往往各个输入端口是独立进行计算的，可以充分利用每个端口的传输带宽（线速）。\
      由于路由器的工作负载很大，一般转发操作的时间仅在 ns 级，因此一般使用专用芯片进行转发操作。\
      ==== 输入端口：
        输入端口将数据读进缓冲队列，再以严格的先进先出策略处理每个报文，具体的转发策略有两种：
        - 基于目的地址的转发：只考虑目的地址，不考虑源地址，计算简单但不能进行复杂的管理

          匹配方法：现代路由器往往使用最长前缀匹配规则，也就是根据地址前缀在路由表中查询，找到最长的前缀匹配项。\
          优势：
          + 速度快，可以处理大量网络流量
          + 现代路由器往往利用一种特殊硬件 ternary content addressable memories (TCAMs)，可以以极快速度并行完成百万级路由表的前缀匹配

        - 基于任意地址的转发：可以根据数据报文中任何字段

        排头阻塞：类似于传输层，在数据平面上，也可能出现输入端口被大排头阻塞，后续报文对应的输出端口空闲但得不到利用的情况。另一情况是，两个相同入口，出口的包，后一个包必须等待前一个包完整移动到出口后才能移动。\
      ==== 交换结构
        将报文从输入端口的缓冲区域传输至输出端口，大致有三种经典交换结构：
        - 共享内存

          最早期的交换结构实现，不需要专用的芯片，只需要输入端口输出端口使用一个共享内存，控制平面的路由处理器控制读写。

          问题：内存读写速度远远低于端口线速；必须使用类似中断处理的技术进行管理，延迟太大。现代处理器可能会采用其的一个改进版。
        - 共享总线

          在硬件上实现输入端口与输出端口的直连，无需处理器干预。\
          输入端口查找完转发表后，给报文加上标签，通过共享总线广播给所有输出端口，输出端口根据标签决定是否接收报文。

          问题：总线一次只能广播一个报文，且交换速率受总线带宽的制约。
        - 纵横式 Crossbar

          使用 $2N$ 条总线连接 $N$ 个输入端口和 $N$ 个输出端口，以方格形式连接。方格的每个节点标识自己是否被占用，只要两条转发路径不相交，就可以同时进行转发。\
          实际使用中，这 $2N$ 条总线已经可以很好地实现全交换，但还可以进一步改进，使用更加复杂的交换结构和更多的总线。
      ==== 输出端口
        输出端口同样利用缓冲队列，将缓冲队列的数据报文发出。与输入端口不同，输出端口不需要遵循先进先出，可以按照更好的性能目标进行优化。\
        除了先进先出外，还有以下调度机制：
        + 基于优先级的调度机制：
          - 根据数据包头判断优先级
          - 按照优先队列，总是先发送高优先级报文
          - 实际实现时，采用多个队列代表不同优先级而不是二叉树等数据结构，提高芯片性能。
          - 问题：优先级难以确定，容易导致公平性问题，低优先级报文可能永远得不到发送
        + 轮询调度：
          将报文分为多个类，每次轮询所有队列，依次发送
        + 加权公平队列：
          类似上面两种策略的组合，在轮询中为每个队列设置权值，高优先级的队列会被更多轮询，同时低优先级队列也可以得到处理
        RFC 标准中，建议典型的输出缓冲区大小为 $"RTT" times "链路带宽"$，但以现在的技术指标来看数值过大并不合理。实际上往往使用的是 $("RTT" times "链路带宽")/(sqrt(N))$，其中 $N$ 表示当前网络流的数量，也就是相同网络地址的数据报文的数量（有时也会区分端口，有时不做区分）。这是因为往往单个流内的数据会进行拥塞控制等机制，不太可能一次发送过多数据。\
        缓冲区溢出时，选择性地丢弃报文，同样有不同的策略。\
    === 控制平面
      负责计算转发路径，由路由器上独立的路由选择处理器进行
      - 传统控制平面：由每个交换机上的路由算法模块协作完成
        路由协议：实际上就是类似在图中最短路算法。路由器往往配备多种路由协议，同时也可设置为不执行任何路由协议，按照管理员的设定进行转发，称为静态路由。\
        路由管理将通过目的地，路由协议和优先级等，将计算路径并下发至转发表。往往不同算法会给出不同的路径，路由器内部将设置优先级，选择优先级最高的路径。
      - 中心化控制平面：由中心化的控制器计算路由，路由器上只需要通过控制代理模块与中心控制器通信并安装于路由器即可

    事实上，现代路由器往往集成了大量其他功能，包括大量网络层应用层协议栈等等。
  == 分片与重组
    internet 协议最基础的功能是寻址和分片。
    - MTU：最大传输单元，分为链路 MTU 和路径 MTU
    - 分片策略：分为允许途中分片和不允许途中分片，前者可以在每一跳过程中进行分片，后者必须在传输前感知路径 MTU 按其进行分片
    - 重组：将分片的数据包重组，途中重组对网络设备负担过大，往往采用目的端重组的方式。
  == 网络层协议：IPV4
    - 通过目的 IP 地址和源 IP 地址表明数据报文的目的地和源头
    - 允许中途分片，可能发生多次分片，分片后的报文与原始报文具有相同头部，最后一定在目的端才进行重组。设计之初希望兼容不同链路 MTU，链路 MTU 减小时分成更小的片，往往在目的端再进行合并
    - 分片利用标识，标志，片偏移三者进行标记，标识用于标记同一数据报文，标志用于标记是否还有后续分片，片偏移用于标记当前分片在原始数据报文中的位置（相对开头的字节数）。
    - 设置 TTL 生存周期，减为零时直接丢弃
    - 设置头部校验和，防止无效传输（这里的校验和只计算首部，不计算数据部分）
    - 报文头部标识了上一层协议的类型（TCP或UDP）
    - 头部总长（在无选项的情况下）为 20 字节，配合 TCP 的 20 字节头部，共计 40 字节
    === IP 地址
      真正进行数据交换的实际上是网络设备的接口，IP 地址按照接口分配，接口之间以链路层相连。\
      IP 地址设计之初，希望所有网络接口都有唯一一个标识它的 IP 地址，但实际使用中使用了大量诸如子网，NAT 等技术，使得网络产生了分级结构，IP 地址在每一级网络中将有不同的含义。\
      全球 Internet 的 IPV4 地址是分级分发的，由 ICANN 分配给区域性因特网注册机构，再分配给 ISP，再由 ISP 分配给用户。这种分配策略被称为无类别域间路由（Classless Interdomain Routing, CIDR）。一个 CIDR 地址分为前缀部分和其他部分，每个前缀部分对应一块连续的地址，这块地址被统一分配给某一组织，进而组织内部的设备就仅有除前缀外的部分不同。对于组织外的路由器，进行转发时只需要将包转发到这个组织的子网之中即可，不关心具体的主机序号，这大大降低了转发表的复杂度。\
      前缀还可以进一步划分为更长的前缀，对应子网划分成更细的子网。小子网聚合成为大子网称为路由聚合，对于路由器，除非它有直接发往小子网的路径（按照最长前缀匹配），否则它不需要关心小子网的结构，只负责把包转发给最大的子网。\
      除此外，还有一些特殊地址，例如 255.255.255.255 & subset_mask 留作局部广播地址，负责向子网内所有设备广播，但不会被路由器向外转发。 0.0.0.0 & subset_mask 留作保留 “本主机” 地址\
    === IP 包转发
      在实际的网络中，同一子网间的网络设备将会按照 MAC 地址进行转发（包括子网设备到路由器，路由器到子网设备两个方向），不同子网间的网络设备将会按照 IP 地址进行转发。\
      问题：如何通过 IP 地址查找 MAC 地址？\
      解决方案：ARP 协议：
        - 通过广播的方式，询问目的 IP 地址对应的 MAC 地址。
        - 找到一次后，将结果缓存，下次直接使用。

      ARP Spoofing 攻击：
        
        由于 ARP 协议是无状态的，如果攻击者随意发送 ARP 响应，路由器即使没有发出 ARP 请求，也会在缓存表中将该响应记录，从而导致路由器将数据报文发送至攻击者，攻击者可以进行中间人攻击。
  == 其他数据平面协议
    === DHCP 协议：IP 地址分发
      某个组织的一块 IP 地址必须逐个分发给每个设备，手工分发显然是不具有效率的，因此需要动态主机配置协议（Dynamic Host Configuration Protocol, DHCP）。\
      每个子网中至少需要一台 DHCP 服务器或者 DHCP 中继代理，代理到负责该子网的 DHCP 服务器（往往已经集成在现代路由器中），具体的 DHCP 分为四个步骤：
      - DHCP Discover：新加入网络的设备向子网内广播 DHCP Discover 报文，请求 IP 地址。这个 IP 地址使用特殊目的 IP 地址 255.255.255.255 和特殊源地址 0.0.0.0，报文数据中包含一个事务 ID。链路层负责将这个包转发给子网中所有节点
      - DHCP Offer：DHCP 服务器收到后，分配一个 IP 地址，以广播形式发送 DHCP Offer 报文，报文中包含 IP 地址，子网掩码，默认 DNS 和第一跳路由器（默认网关），租约时间等信息。报文中包含事务 ID，以便客户端识别
      - DHCP Request: 客户端的 offer 可能同时被多个 DHCP 服务器接收，客户端收到后，选择一个 offer，广播 DHCP Request 报文，报文中包含 offer 中的配置参数
      - DHCP ACK：服务器收到后，以广播形式发送 DHCP ACK 报文，报文中包含客户端的配置参数，客户端收到后，配置自己的网络接口，完成配置。
      问题：移动网络中不能维持一个固定的 IP 地址
      - 安全问题：
        + DHCP 耗竭攻击：攻击者短期内发送大量 DHCP Discover 报文，耗尽 DHCP 服务器的 IP 地址资源
        + 流氓 DHCP 服务器：攻击者在网络中设置 DHCP 服务器，向客户端发送虚假的 DHCP Offer 报文，将客户端的流量重定向至攻击者的服务器
    === NAT 协议：IP 地址转换
      NAT 全称为网络地址转换，用于解决 IPv4 地址不足的问题。子网内部向外部通讯时，必须经过转换才能实现正常通讯。\
      私有 IP 地址往往是：
      - 10.\*.\*.\*
      - 172.\*.\*.\*
      - 192.\*.\*.\*
      子网和公网的连接处称为 NAT 节点。子网内部设备发送数据包至节点，节点以自己的公网身份和用于区分子网内部设备的端口号（在转发时动态分配并记录端口号与 （IP， 端口）的一一对应），将数据包发送至公网。\
      等到收到回复时，再根据对应表发回至子网内部设备。\
      #remark[][
        对于 TCP 和 UDP 数据，NAT 协议往往可以选择将区分两种数据分开进行管理
      ]
      问题/缺点：
      - 内部设备违背 IP 结构模型，直接让路由器处理传输层协议
      - 违反了端到端的原则，同时也破坏了协议分层
      - 从外部看无法区分内部设备的恶意行为，可能造成误封
      - 导致 IP 地址无法加密
    === ICMP 协议
      用于报告网络状态是否出现差错，最经典的就是 ping 命令和 traceroute （用于探测整个路径上的路由器地址），差错包括：
      - 3：终点不可达：路由器上转发表没有路径，协议无法识别......
      - 5：路由重定向
      - 11：超时（TTL 过期）。由于 TTL 的初始值没有规定，各个操作系统都设置了不同的初始值，可以用来探测对方的操作系统
      - 12：参数问题
  == 控制平面（路由）协议
    为了解决具体的路由路径问题，常常将网络节点和通路抽象成一个有权图。权可以是 1,也可以是带宽的倒数，以及其他拥塞相关的参数等。\
    路由选择算法的核心就是在给定节点之间找到代价最短的路径，本质上就是一个最短路算法。\
    经典的最短路算法：
    - Dijkstra 算法
    - Bellman-Ford 算法
    应用算法时，需要考虑现实情形中，每台路由器资源有限（简单性），各个路由器独立异步工作（异步性），网络状态不断变化，甚至发生故障（鲁棒性），每条路径不能消耗过多的带宽资源（公平性），也因此计算机网络中的路由选择算法是一个很值得研究的话题。
    + 路由器是否知道全局信息？
      - 知道全局信息：链路状态算法（基于 Dijkstra）
      - 不知道全局信息：每个路由器节点只知道邻居节点的开销：距离向量算法（基于 Bellman-Ford）
    + 动态改变链路权重？
      - 静态（基本不现实）
      - 动态
    == Bellman-Ford 与距离向量
      Bellman-Ford 算法：
        $
        d_x (y) = min_v {c(x, v) + d_y (v)}
        $<bellman-ford>
      问题在于如何将其分布式计算，包括：
      - 数据的分布式：将单机算法维护的信息分散到每个节点

        所谓距离向量，就是每个节点只维护自己的距离向量: 
        $
        vec(d_x (1), d_x (2), dots.v, d_x (n))
        $ 
        以及它的所有邻居的距离向量，这就是每个节点应用 Bellman-Ford 算法所需要的全部信息。
      - 计算的分布式：将算法更新操作分散到各个节点

        每个节点的计算步骤为：
        + 发送：向邻居节点发送自己的距离向量
        + 接收：接收来自邻居的距离向量
        + 计算：使用 @bellman-ford 更新自己的距离向量
      算法特点：
      - 异步：节点节奏不需要一致
      - 迭代
      - 分布
      - 链路状态改变时，会快速从发生变化的节点开始向外传播。同时，"好消息快速传播，坏消息传播慢"。若某个链路代价变成极大值，收敛速度不可接受，被称为无穷计数问题。\
        解决方法：
          + 毒性逆转\
            无穷计数问题来自于距离向量并不保存最短路的路径，因此可以通过其他手段保持最短路从而避免问题，例如毒性逆转就是若 $a -> c$ 的最短路的第一步到 $b$，则 $a$ 报告 $b$ $D_a (c) = + infinity$（这是合理的，显然此时 $b -> c$ 最短路不会经过 $a$）\
            然而，它仍然不能彻底解决无穷计数问题，仍然有可能因为第二跳及之后的链路环境严重恶化导致缓慢收敛。
    === 链路状态算法
      要求每个节点知道完整的网络拓扑与链路开销。\
      Dijkstra：每次向已知最短路节点集加入距离最短的点，同时更新其他节点到已知最短路节点集的最短距离。\
      链路状态算法可分为五步：
      + 发现邻居，了解对方的网络地址
      + 设置到每个邻居的成本度量：可以人工配置，通过试探延迟或者链路带宽自动设置
      + 构造分组链路状态分组（Link State packet, LSP），包含之前收到的信息
      + 将 LSP 广播出去，从而每个路由器都知道整个网路的链路状态。
        - 如果收到新分组，会将这个分组广播给其他所有的链路，称为洪泛广播
        - 如果是重复分组（网络中可能有回路）或者过时分组，直接丢弃
    两种算法相比：
    - 消息数量最多都是 $O(n E)$（$E$ 为边数）
    - 链路状态算法每个节点花费 $O(n log n)$ 完成计算，链路状态算法可能发生无穷计数
    - 一旦网络状态改变，链路状态算法影响较小，而距离向量算法可能造成大量错误计算结果，传播大家严重
    - 路由器的运算能力和存储能力有限，可能难以支撑链路状态算法。曾经在很长一段时间距离向量算法都是主流，随着芯片的发展链路状态算法也得到更多的使用。
  == 层次路由
    === 自洽网络系统（AS, Autonomous System）
      意指每个管理机构内部的网络，往往使用相同的路由算法、协议。每个 AS 具有全球唯一的 ID 号，自洽系统可能包含小的自洽系统。\
      自洽系统内部使用的路由协议称为内部网关路由协议 Interior Gateway Protocol, IGP，自洽系统之间使用的路由协议称为外部网关路由协议 Exterior Gateway Protocol, EGP。\
      显然 IGP 可以多种多样，典型的包括 OSPF 开放最短路径优先协议 Open Shortest Path First（将 AS 再具体划分为不同区域，区域间只同步区域间链路，区域间有层次结构，上层区域称为主干，非主干区域不能互相发布路由信息，对应链路状态算法）, RIP Routing Information Protocol（对应距离向量算法，使用跳数作为距离，最多只能包含15个路由器以解决无穷计数问题）, IS-IS 等等\
      而 EGP 必须统一，典型的是 BGP 协议\
    === BGP 
      AS 间路由难度很大，主要面临超大规模（百万级别路由器）和策略问题（各个 AS 间往往涉及商业利益等问题难以协调，同时采用的路由协议也不同）。\
      由此产生了 BGP Border Gateway Protocol，作为唯一运行的 EGP 协议，功能包括：
      - eBGP：从相邻的 AS 获得网络可达信息
      - iBGP：在 AS 内部传播网络可达信息
      具体分为：
      - 路由器之间建立连接，通告路径。每个路径包括路径前缀（目的网络）+ 属性（AS路径，经过的所有 AS 号; 下一跳，说明路由信息对应的下一跳的 IP 地址），网关路由器可以选择接受或拒绝。一但接受，就通过 iBGP 传播到内部所有路由器。如果有多条路径，可能根据策略选择不同的路径，以优先级从高到低包括：
        + 本地偏好值属性：人为指定的策略变量
        + 路径长度
        + 下一跳距离
        + 其他附加标准
        + 最低路由器 ID
      - 路由器也要根据策略决定是否向相邻 AS 通告路径信息
      - 实际转发时，AS 内部路径也按照一定策略选择。典型的是热土豆策略，也即尽快离开本地 AS
      （注意 BGP 中所有包都通过 TCP 协议交付，因此非常严格地说是应用层协议，但是功能是网络层的延伸）
  == 其他路由功能
    === 广播路由
      如果主机想要向网络中所有机器发送消息，如何实现？显然知道所有设备 IP 地址代价太大，因此现代路由器往往采取更简单的方式，例如：
      + 泛洪

        就是路由器把进入数据包发送到所有（除进入线路）外的线路上。然而网络中往往有回路存在，如果多个路由器都选择泛洪操作，可能造成广播风暴
      + 序号控制泛洪：为每个广播包加上序号，很容易拒绝到重复的广播消息
      + 逆向路径转发：假设路由表已经计算完毕，从而路由表表示到达各网络的最优路径，只按最优路径转发。
      + 生成树：构建最小生成树，按最小生成树转发，最佳使用带宽
    === 组播路由
      源目标向网络中一部分机器发送数据。实现步骤：
      + 确定组成员
      + 如何编址
      ==== IGMP 协议
        Internet Group Management Protocol，用于机器向路由器声明自己加入某个组播组。
      
      然而，当今的互联网设备许多都是单播设备，这时需要隧道技术，将组播数据穿过那些只支持单播的设备
    === 选播路由
      许多时候我们并不需要指定目标，只需要收到响应即可，典型例子如 DNS 服务，这时可以利用选播技术。
  == 软件定义网络
    相较于一种技术，SDN 更像是思想或者理念，包括大量具体的技术。
    - 传统的网络基本不可编程，只能通过硬件定义的功能使用，比较死板
    - 传统路由算法中，往往都要不断向邻居传播消息，而现代网络设备数量不断增加，负载很大
    - 网络中流量往往是很有特征的，如果能适当规划流量的传播路径可以有效提高传输效率。传统的基于最短路的算法达到局部最优，但有可能将大量流量压到同一链路上。为了更优的计算路径需要网络流等更加复杂的算法。

    SDN（软件定义网络）的优势：
    - 数据平面提供开发接口，可以编程
    - 控制平面由中心化控制器决定，以全局视角进行更好的网络管理

    面临的挑战：
    - 高校、标准组织 ONF 的市场影响力和工程背景都太弱
    - 牵扯到太多利益关系，传统厂商不买账

    SDN 设备：
    - SDN 交换机：提供开放协议接口，类似于微处理器
    - SDN 控制器：类似于网络操作系统，向下与 SDN 交换机交互，向上为上层应用提供接口，物理上以分布式系统实现。

    === OpenFlow 协议
      - 核心是基于开放协议，模拟网络中各种机器的抽象“匹配-转发”操作。匹配+动作被称为流表，具体来说，流表包括：
        - 首部字段的集合，用于在 TCAM 内存中匹配进入报文，允许使用 $*$ 做通配符，例如 $128.119.*.*$，多个相同匹配时按照流表自身的优先级解决
        - 计数器集合：包括已经与该表项匹配的包数量以及上次更新时间等信息
        - 动作集合：重写首部，转发分组，丢弃分组，复制分组，例如 drop, forward(2), send to controller, send to processing piepline, modify fields
      - 问题：匹配规则和动作是固定且无状态的
  == 其他网络层技术
    === IPV6
      - 提出目的：解决 IPV4 地址不足的问题，同时尽量解决历史遗留问题
      - 以 128 bit 表示地址。习惯上用 $:$ 进行分隔。由于往往有很多零，允许用 "::" 表示省略若干零（规定只能使用一次）
      - IP 报文头部固定 40 字节，不允许途中分片，分片过大直接返回分片过大对应的 ICMP 消息即可。相较于 IPV4，头部省略了很多内容，包括校验和（留给传输层的 TCP/UDP 协议），分片消息，头部长度等等字段。
      - 增加了流标签，表明发送方需要特殊处理
      - 扩展头：IPV6 设置了不定数量的扩展头，允许使用额外的机制，例如分片，指定路径等等。
      - 改进的 DHCP, ICMP 等等协议
      - IPV6 的普及十分缓慢，有一系列的过渡技术，包括：
        + 隧道：假设两个设备使用相同的网络类型，但中途某一段使用另外的不兼容的网络类型，我们可以在通过这部分是，按照这部分的网络类型进行隧道封装，离开时再解包。
        + 翻译：将 IPV4 与 IPV6 的头部进行转换。注意传输层（甚至应用层）可能使用 IP 地址做校验等等，因此需要逐一转换
    === 网络服务质量技术
      尽管通常的网络实践并不在网络层管理网络质量，在一些特殊网络中网络质量管理技术也得到了应用。常见方法包括：
      + 数据包调度：在路由器输出端口决定何者优先输出
      + 流量工程：假设我们事先可以估计流量的信息，可以事先为流量规划合理的流量。
      + 流量整形：把不规则的流量特征整理成规则的流量发出，典型算法包括：
        - 漏桶算法：设置漏桶，溢出时一次性发送，可以平滑流量
        - 令牌桶算法：设置令牌桶，均匀生成令牌（若已达上限就丢弃）。数据包以大小对应需要令牌的量，如果令牌不足则直接丢弃数据包
      + 综合服务：在互联网上维护连接状态，用预留资源提供服务保障。这要求所有路由器都提供复杂的支持，因此只是被设计，基本没有被真正实现
      + 区分服务：利用 IP 报头中指明的优先级区分服务优先级。但互联网上用户很难感知其他用户和全局的网络状态，很容易造成滥用，产生“公地悲剧”
    === 网络连接服务
      尽管因特网在网络层是无连接的，但一些技术希望建立逻辑上的连接
      + 虚电路：在因特网上为双方建立逻辑上的连接，并无真正物理上的连接。来源于分组交换机制只是早期的偶然选择，希望利用虚电路技术来解决分组交换的一些问题，但由于分组交换使用已经非常广泛，虚电路并没有真正广泛使用。
      + MPLS：多协议标签交换。介于网络层和链路层之间的协议，希望能够跨越网络层协议的地址表示方法，提供统一的虚拟化地址，每个路由器只需要按照虚拟化的标签转发即可。
      + VPN：
        - 起源：许多机构希望建立专用网络，但物理上完全专用的网络成本过于高昂，因此出现了 VPN(Virtual Private Network) 也就是建立在 Internet 基础上，保持逻辑上隔离的网络。
        - 设计原则：安全性、隧道与加密、数据验证、用户验证、防火墙与攻击检测
        - 核心思想：通过类似隧道的技术，穿过公共网络将两个私有网络连接起来，并在网关之间保证数据的加密和防篡改
    === SR(Segment Routing)
      集中式与分布式结合的设计，用于改进经典 SDN 的拓展性问题，可靠问题（单点故障难以避免），性能问题。\
      原理：源路由机制，将路径段的规划也全部交给端系统，在报文头中全部指定。
      - 可以采用 MPLS 或 SRV6 （以 IPV6 头部扩展的形式）实现报文中记录路径段信息

]
#chapter2